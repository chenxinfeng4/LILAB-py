# python -m lilab.outlier_refine.s1_pot_player_errorframe /A/B/C
# %%
from PIL import Image, ImageTk
import base64
from aip import AipOcr
import io
import glob
import os.path as osp
import json
import tqdm
import pytesseract
import cv2
import numpy as np
import argparse
# imgfile = '2022-04-26_15-06-02_bwt_wwt_7.mp4_20220509_155402.017.png'

APP_ID = '25907660'
API_KEY = 'GvKz2KuhvFzLq6NWLp4SwiEm'
SECRET_KEY = 'xgbvEZVFQCc17O6jZY5Ug8Y3kCHD5V35'
client = AipOcr(APP_ID, API_KEY, SECRET_KEY)


#%% 
def get_num(imgfile):
    img = Image.open(imgfile)
    # img_num = img.crop([6, 2, 250, 70])
    img_num = img
    bio = io.BytesIO()

    img_num.save(bio, format="PNG")
    byte_img_num = bio.getvalue()
    res_image = client.basicGeneral(byte_img_num)
    if res_image['words_result'] == []:
        return None
    str验证码 = res_image['words_result'][0]['words']
    str验证码 = ''.join(filter(str.isalnum, str验证码))
    str验证码 = ''.join(filter(str.isascii, str验证码))
    if str验证码 is None:
        print('没有输入验证码')
        num = None
    elif str验证码.isdigit():
        num = int(str验证码)
    else:
        num = None
    return num

def get_num_tesseract(imgfile):
    img = Image.open(imgfile)
    # img_num = img.crop([6, 2, 250, 70])
    img_num = img
    bio = io.BytesIO()

    img_num.save(bio, format="PNG")
    byte_img_num = bio.getvalue()
    img = cv2.imdecode(np.frombuffer(byte_img_num, np.uint8), cv2.IMREAD_COLOR)
    img_red = img[:,:,2]
    thr = cv2.threshold(src=img_red, thresh=110, maxval=255, type=cv2.THRESH_OTSU + cv2.THRESH_BINARY_INV)[1]
    thr = cv2.threshold(thr, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]
    thr = cv2.medianBlur(thr, 3)
    # ocr the number
    out = pytesseract.image_to_string(thr)

    if len(out)<=2:
        num = get_num(imgfile)
        print('Fail to get num by tesseract, use baidu ocr')
    else:
        try:
            num = int(out[:-2])
        except ValueError:
            num = get_num(imgfile)
    return num

#%%
# error_imgs = ['A/B/2022-04-26_15-06-02_bwt_wwt_1.mp4_20220509_153219.553.png']
dir = '/mnt/liying.cibr.ac.cn_Data_Temp/multiview_color/20220613-side6-addition/2022-2-24-side6-bwrat-shank3/for_label_refine20220901/white/merge'

def dump_json_from_dir(dir):
    findext = lambda x: glob.glob(osp.join(dir, x))
    error_imgs = findext('*.png') + findext('*.jpg')
    error_imgs = [osp.basename(error_img) for error_img in error_imgs
                if '.mp4' in error_img]

    error_videos = [error_img.split('.mp4')[0]+'.mp4' for error_img in error_imgs]
    index_processed = [False for _ in range(len(error_imgs))]
    outdict = {error_video:[] for error_video in error_videos}
    faillist = []
    for i, (error_img, error_video) in enumerate(zip(tqdm.tqdm(error_imgs), error_videos)):
        if index_processed[i]:
            continue
        num = get_num(osp.join(dir,error_img))
        if num:
            outdict[error_video].append(num)
        else:
            faillist.append(error_img)
        index_processed[i] = True

    # %%
    num = get_num(osp.join(dir,error_img))
    #%%
    outjson = osp.join(dir, 'out.json')
    with open(outjson, 'w') as f:
        json.dump(outdict, f, indent=4)


if __name__=='__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('dir', type=str)
    args = parser.parse_args()
    dump_json_from_dir(args.dir)